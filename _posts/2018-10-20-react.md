---
layout: post
title:  "üèÅ  GUIA RAPIDA DE REACTJS"
date:   2018-10-20 19:7:13 +0530
categories: javascript
---

![OOP](https://media.giphy.com/media/13HgwGsXF0aiGY/giphy.gif)

**REACTJS**  Es una libreria de codigo abierto creada y soportada por facebook,
El primer paso para entender reactjs es que usamos codigo javascript con una extension _JSX_  que permite escribir _HTML_ directamente sobre javascript al crear proyectos  SPA's (Single Page Application), nos permitira tener un codigo mas legible y facil de mantener

Sin embargo **JSX** no es un apropiado javascript. **JSX** debe se compilado dentro de javascript.
sera [BABEL](https://babeljs.io/) la herramienta creada para este proceso
Como pasa en algunas ocasiones esta herramienta alertara en caso de error



# ‚ô†Ô∏è INSTALANDO REACTJS

Contamos con multiples maneras de hacerlo,La opcion mas rapida es la siguiente tener instalado :

[npm](https://www.npmjs.com) √≥ [yarn](https://yarnpkg.com/en/)  son gestores de paquetes muy utiles

* Tener NodeJs >= 4.
* Abrimos la terminal y usamos los siguientes comandos

Instalaremos  el paquete global de  Create React App:


> npm install -g create-react-app

Ingresar a la carpeta en donde pondr√°s tus proyectos y ejecutar:

>  create-react-app nombreProyecto

Y por √∫ltimo, iniciar la aplicaci√≥n:

>  npm start

Si todo funciona correra en el puerto 3000. Se abrira  el navegador,
de lo contrario , s√≥lo usamos la siguiente  direccion:  **http://localhost:3000** y  de React estara listo!!!


## ‚ô†Ô∏è Ejecutando las primeras lineas

Si todo ha salido bien **REACT** crea un componente llamado **App** representado por el archivo **App.js**, este componente es utilizado en el archivo **index.js** donde podemos empezar.

```javascript
import React, { Component } from 'react';

class App extends Component {
  render() {
    return (
      <div>
        <h1>Primera aplicacion ReactJS</h1>
        <h2> Create React App --Aqui comienza todo -- </h2>
      </div>
    );
  }
}
export default App;

```

## ‚ô†Ô∏è Como a√±adir comentarios

```javascript
const JSX = (
<div>
  <h1>Esto es un bloque JSX</h1>
  { /* Esto es un comentario */ }
  <p>mensaje creado de forma aleatoria</p>
</div>);

```
## ‚ô†Ô∏è Renderizando el DOM


Para este SCRIPT tenemos un __div__ con un **_id_**   llamado **'reactMensaje'** listo para ejecutarse

```javascript
const JSX = (
<div>
  <h1>MENSAJE DESDE REACT</h1>
  <p>RENDERIZANDO EL DOM</p>
</div>
);
ReactDOM.render(JSX, document.getElementById('reactMensaje'));
```

El primer elemento de REACT es renderizado y el segundo es el DOM
donde queremos renderizar el componente tambien
**ReactDOM.render()** es llamado despues de las declaraciones de elemento de  **JSX**, es conveniente declarar
las variables antes de usarlas


## ‚ô†Ô∏è Entendiendo jsx


Una de las diferencias de escribir en **REACTJS** con **JSX**  es que no se pueden nombrar las clases como lo hacemos con HTML o creara un mensaje de error en consola, el motivo es que en  **JAVASCRIPT**  la palabra **class** esta reservada. La forma correcta es escribirlo es asi **className**



```javascript
const JSX = (
<div className = 'myBloque'>
  <h1>a√±adiendo class en este bloque</h1>
</div>);

```

## ‚ô†Ô∏è Cerrado de etiquetas

Otra diferencia que nos encontraremos es prestar atencion al cerrado de etiquetas lo normal es <div></div>
sin embargo  escribi esto ```<br></br> ``` dara un error,lo apropiado es ``` <br/>```

Cualquier elemento JSX puede escribirse con una etiqueta de cierre autom√°tico, y cada elemento debe estar cerrado. La etiqueta de salto de l√≠nea, por ejemplo, siempre debe escribirse como <br /> para que JSX sea v√°lida y pueda ser transpilada. Un <div>, por otro lado, puede escribirse como <div /> o <div> </div>. La diferencia es que en la primera versi√≥n de sintaxis no hay forma de incluir nada en <div />.


```javascript

const JSX = (
<div>
  {}
  <h2>HELLO  React!</h2> <br />
  <p>Revisar que las etiquetas esten cerradas</p>
  <hr />
  {}
</div>
);
```

## ‚ô†Ô∏è  Crear un stateless-functional-Component


Los componentes son el n√∫cleo de **React**.

> Todo en React es un componente

y Hay dos formas de crear un componente React.

La primera forma es usar una funci√≥n de JavaScript,La definici√≥n de un componente de esta manera crea un componente funcional sin estado.

El concepto de estado lo escribire mas adelante. ahora, piense en un componente sin estado como uno que puede recibir datos y procesarlos, pero no administra ni rastrea cambios en esos datos.

Para crear un componente con una funci√≥n,  es simple escriba una funci√≥n de JavaScript que devuelva **JSX** o nulo. Una cosa importante a tener en cuenta es que **React** requiere que el nombre de su funci√≥n comience con una letra may√∫scula. Aqu√≠ hay un ejemplo de un componente funcional sin estado que asigna una clase **HTML** en **JSX:**

```javascript
const MiComponente = function() {

  return (
    <div>
      MENSAJE
    </div>
  );

}
```

## ‚ô†Ô∏è  Crear un React Component

En React.Component. El constructor es un m√©todo especial utilizado durante la inicializaci√≥n de objetos que se crean con la palabra clave de clase. Es una buena pr√°ctica llamar al constructor de un componente con super, y pasarle props a ambos. Esto asegura que el componente se inicialice correctamente.

```javascript


Class Gato extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <h1>saludos!!</h1>
    );
  }
}

 ```

## ‚ô†Ô∏è Crear un Component con Composition

Ahora veremos c√≥mo podemos componer varios componentes de React piensa que est√°s creando una aplicaci√≥n y has creado tres componentes, una barra de navegaci√≥n, un tablero de instrumentos y un pie de p√°gina. Para componer estos componentes juntos, puede crear un componente primario de la aplicaci√≥n que represente cada uno de estos tres componentes como secundarios. Para representar un componente como un elemento secundario en un componente React, incluya el nombre del componente escrito como una etiqueta HTML personalizada en el JSX.


```javascript
const componenteHijo = () => {
  return (
    <div>
      <p>Soy el hijo </p>
    </div>
  );
};

class ComponentePadre extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>soy el padre</h1>

        <componenteHijo />

      </div>
    );
  }
};

```


## ‚ô†Ô∏è  Usar React Render para anidar Components


Hay muchas formas diferentes de componer componentes con React. La composici√≥n de componentes es una de las caracter√≠sticas poderosas de React. Cuando trabaje con React, es importante comenzar a pensar en su interfaz de usuario en t√©rminos de componentes  Usted divide su interfaz de usuario en sus bloques de construcci√≥n b√°sicos, y esas piezas se convierten en componentes. Esto ayuda a separar el c√≥digo responsable de la IU del c√≥digo responsable de manejar la l√≥gica de la aplicaci√≥n. Puede simplificar enormemente el desarrollo y mantenimiento de proyectos complejos.

```javascript
const TiposDeFrutas = () => {
  return (
    <div>
      <h2>Frutas:</h2>
      <ul>
        <li>Manzanas</li>
        <li>Moras</li>
        <li>Frambuesas</li>
        <li>Bananas</li>
      </ul>
    </div>
  );
};

const Frutas = () => {
  return (
    <div>

        <TiposDeFrutas />

    </div>
  );
};

class TiposDeComida extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <h1>Tipos de comida:</h1>

        <Frutas />

      </div>
    );
  }
};

```


## ‚ô†Ô∏è Componer React Componentes

 La representaci√≥n de los componentes de la clase de estilo ES6 dentro de otros componentes no es diferente de la representaci√≥n de los componentes simples.Puede representar elementos JSX, componentes funcionales sin estado y componentes de clase ES6 dentro de otros componentes.


```javascript
class Frutas extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h2>Frutas:</h2>

        <NonCitrus />
        <Citricos />

      </div>
    )
  }
}

class TiposDeComida extends React.Component {
  constructor(props) {
     super(props);
  }
    render() {
      return (
        <div>
        <h1>Tipos de Comida:</h1>

          <Frutas />

          <Vegetales/>
        </div>
      );
    }
};
```

## ‚ô†Ô∏è  Renderizar una Class Component Hacia el DOM

Puede recordar que us√≥ la **API ReactDOM**  anteriormente para representar elementos JSX al DOM. El proceso para renderizar componentes React se ver√° muy similar. Los anteriiores scripts se enfocaron en los componentes y la composici√≥n, por lo que el renderizado se realiz√≥ para usted entre bastidores. Sin embargo, ninguno de los c√≥digos React que escriba se procesar√°n en el DOM sin hacer una llamada a la API ReactDOM. Aqu√≠ hay una actualizaci√≥n de la sintaxis: **ReactDOM.render (componentToRender, targetNode).**

El primer argumento es el componente **React** que desea procesar. El segundo argumento es el nodo **DOM** en el que desea procesar ese componente. Los componentes de React se pasan a **ReactDOM.render ()** un poco diferente a los elementos de JSX. Para los elementos JSX, pasa el nombre del elemento que desea representar. Sin embargo, para los componentes React, debe usar la misma sintaxis como si estuviera representando un componente anidado, por ejemplo, **ReactDOM.render (<ComponentToRender />, targetNode).** Utilice esta sintaxis para los componentes de clase ES6 y los componentes funcionales.


```javascript
Class TiposDeComida extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>Tipos de comida:</h1>

          <Frutas />
           <Vegetales />

      </div>
    );
  }
};
ReactDOM.render(<TiposDeComida />, document.getElementById('nodo'));

```

# ‚ô†Ô∏è Escribir un React Component desde 0


Ahora que ha aprendido los conceptos b√°sicos de los componentes JSX y React, le propongo escribir un componente por su cuenta. Los componentes de React son los componentes b√°sicos de las aplicaciones de React, por lo que es importante familiarizarse con su escritura. Recuerde, un componente t√≠pico de React es una clase ES6 que extiende React.Component. Tiene un m√©todo de procesamiento que devuelve HTML (desde JSX) o nulo. Esta es la forma b√°sica de un componente React. Una vez que entienda esto bien, estar√° preparado para comenzar a construir proyectos React m√°s complejos.


```javascript

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>He creado mi primer componente!</h1>
      </div>
    );
  }
};

ReactDOM.render(<MyComponent />, document.getElementById('nodo'));
```



## ‚ô†Ô∏è Pasar Props a Stateless Functional Component

los scripts anteriores cubrieron la creaci√≥n y composici√≥n de elementos **JSX**, componentes funcionales y componentes de clase de estilo ES6 en **React.** Con esta base, es hora de ver otra caracter√≠stica muy com√∫n en React: **props.** En React, puede pasar propiedades a componentes secundarios. Supongamos que tiene un componente de la aplicaci√≥n que muestra un componente secundario llamado Bienvenido, que es un componente funcional sin estado. Puede pasar la propiedad de bienvenida de un usuario escribiendo:

```javascript

<App>
  <Welcome user='Andresshare' />
</App>
```

Usted usa atributos HTML personalizados creados por usted y respaldados por React para pasarlos al componente. En este caso, el usuario de la propiedad creada se pasa al componente Bienvenido. Como Welcome es un componente funcional sin estado, tiene acceso a este valor as√≠:
```javascript
	const Welcome = (props) => <h1>Hello, {props.user}!</h1>
```

Es est√°ndar llamar a este valor **props** y cuando se trata de componentes funcionales sin estado, b√°sicamente lo considera como un argumento de una funci√≥n que devuelve JSX. Puede acceder al valor del argumento en el cuerpo de la funci√≥n. Con los componentes de clase.revisemos el siguiente script

```javascript
const fechaActual = (props) => {
  return (
    <div>

      <p>fecha: {props.date}</p>

    </div>
  );
};

class Calendario extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>Que dia es?</h3>

        <fechaActual date={Date()} />

      </div>
    );
  }
};

```

## ‚ô†Ô∏è Pasar un Array como Props
En el script anterior se paso informaci√≥n de un componente principal a un componente secundario como propiedades o propiedades. ahora pasaremos las matrices como props. Para pasar una matriz a un elemento JSX, se debe tratar como JavaScript y se debe incluir entre llaves.

```javascript

<ParentComponent>
  <ChildComponent colors={["verde", "rojo", "azul"]} />
</ParentComponent>

```

El componente hijo tiene acceso a los colores de la propiedad de la matriz. Se pueden usar m√©todos de matriz como ```join()``` al acceder a la propiedad. ```const ChildComponent = (props) => <p & gt {props.colors.join (',')} </ p & gt``` Esto unir√° todos los elementos de la matriz de colores en una cadena separada por comas y producir√°: ```<p> verde, azul, rojo </p>``` M√°s adelante, escribire sobre otros m√©todos comunes para procesar matrices de datos en React.

Revisemos el script siguiente de cosas por hacer

 Al representar cada Lista desde el componente de Tareas pendientes, se pasa una propiedad de tareas asignadas a una serie de tareas a realizar, por ejemplo ["pasear perro", "entrenamiento"]. Luego se accede a esta matriz de tareas en el componente Lista, mostrando su valor dentro del elemento p. Usando ```join (",")``` para mostrar ```props.tasksarray``` en el elemento **p** como una lista separada por comas. La lista tiene  2 tareas y la de ma√±ana tiene 3 tareas.


```javascript
const List= (props) => {
  return <p>{props.tasks.join(', ')}</p>
};

class ToDo extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h1>Listado de pendientes</h1>
        <h2>Hoy</h2>
        <List tasks={['estudiar', 'ejercicio']} />
        <h2>ma√±ana</h2>
        <List tasks={['comprar manzanas', 'ordenar boletas', 'comprar agua ']} />
      </div>
    );
  }
};
```

## ‚ô†Ô∏è Usar Props por defecto

React tambi√©n tiene una opci√≥n para establecer props predeterminados. Puede asignar props predeterminados a un componente como una propiedad en el propio componente y React asigna el apoyo predeterminado si es necesario. Esto le permite especificar lo que debe ser un valor de propiedad si no se proporciona ning√∫n valor expl√≠citamente. Por ejemplo, si declara ```MyComponent.defaultProps = {location: 'Miami'},``` ha definido un prop de ubicaci√≥n que se establece en la cadena Miami, a menos que especifique lo contrario. React asigna propiedades predeterminadas si las propiedades no est√°n definidas, pero si pasa nulo como el valor de una propiedad, permanecer√° nulo.

```javascript

const carroDecompra = (props) => {
  return (
    <div>
      <h1>Componente de carro de compra </h1>
    </div>
  )
};

carroDecompra.defaultProps = {
  items: 0
}
````


## ‚ô†Ô∏è sobrescribir Default Props

La capacidad de establecer props predeterminados es una caracter√≠stica √∫til en React. La forma de sobreescribir los props predeterminados es establecer expl√≠citamente los valores de prop para un componente


```javascript
const Articulos = (props) => {
  return <h1>Cantidad de articulos: {props.cantidad}</h1>
}

Articulos.defaultProps = {
  quantity: 0
}

class CarroDeCompras extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {

    return <Articulos cantidad = {10} />

  }
};

```

## ‚ô†Ô∏è Usar PropTypes para Definir las Props esperadas

React proporciona funciones √∫tiles de verificaci√≥n de tipos para verificar que los componentes reciban props del tipo correcto. Por ejemplo, su aplicaci√≥n hace una llamada a la API para recuperar datos que espera estar en una matriz, que luego se pasa a un componente como prop. Puede establecer **propTypes** en su componente para requerir que los datos sean de tipo array. Esto arrojar√° una advertencia √∫til cuando los datos sean de cualquier otro tipo.

Se considera una buena pr√°ctica establecer los tipos de propiedades cuando conoce el tipo de propiedad con anticipaci√≥n. Puede definir una propiedad **propTypes** para un componente de la misma manera que defini√≥ los Predeterminados predeterminados. Al hacer esto se verificar√° que los accesorios de una clave dada est√©n presentes con un tipo dado. Aqu√≠ hay un ejemplo para requerir la funci√≥n de tipo para un prop llamado ```handleClick: MyComponent.propTypes = {handleClick: PropTypes.func.isRequired}``` En el script anterior, la parte ```PropTypes.func``` verifica que ```handleClick``` es una funci√≥n. Agregar ```isRequired``` le dice a React que ```handleClick``` es una propiedad requerida para ese componente. Ver√° una advertencia si no se proporciona.

Tambi√©n note que ```func``` representa la funci√≥n. Entre los siete tipos primitivos de JavaScript, la funci√≥n y el booleano (escrito como bool) son los √∫nicos dos que utilizan una ortograf√≠a inusual.

Adem√°s de los tipos primitivos, hay otros tipos disponibles.

```javascript

const Articulos = (props) => {
  return <h1>Cantidad de articulos: {props.cantidad}</h1>
};

Articulos.propTypes = {
  cantidad: PropTypes.number.isRequired
};


Articulos.defaultProps = {
  cantidad: 0
};

class CarroDeCompras extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return <Articulos />
  }
};
```

## ‚ô†Ô∏è Acceder a Props usando this.props

En el  script anterior  pase  las *props* a los componentes secundarios. Pero, ¬øqu√© sucede si el componente secundario al que le est√° pasando un props es un componente de clase ES6, en lugar de un componente funcional sin estado? El componente de clase ES6 utiliza una convenci√≥n ligeramente diferente para acceder a accesorios. Cada vez que refiera a un componente de clase dentro de s√≠ mismo, use esta palabra clave.

Para acceder a los accesorios dentro de un componente de clase, debe comenzar con el c√≥digo que usa para acceder a √©l. Por ejemplo, si un componente de clase ES6 tiene una propiedad llamada datos, escribe ```{this.props.data}``` en JSX.

``` javascript
class devuelveClaveTemporal extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
            <p>su clave temporal es: <strong>{this.props.tempClave}</strong></p>
        </div>
    );
  }
};

class ReinicioClave extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
          <h2>Reiniciar clave</h2>
          <h3>nuevo clave temporal para ud</h3>
          <h3>reinicie el password de su cuenta.</h3>
          <ReturnTempPassword tempPassword="BerACDFPbq34n55z1" />
          class ReturnTempPassword extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
            <p>Su clave temporal es: <strong>{this.props.tempClave}</strong></p>
        </div>
    );
  }
};

class ResetPassword extends React.Component {
  constructor(props) {
    super(props);

  }
  render() {
    return (
        <div>
          <h2>Reiniciar Clave </h2>
          <h3>clave temporal</h3>
          <h3>configure el reser de su cuenta de usuario.</h3>

          <devuelveClaveTemporal tempClave="BerACDFPbq34n55z1" />

        </div>
    );
  }
};
        </div>
    );
  }
};


```

## ‚ô†Ô∏è Usando Props con Stateless Functional Components
Un componente funcional sin estado es cualquier funci√≥n que usted escribe que acepta props y devuelve JSX. Un componente sin estado, por otro lado, es una clase que extiende **React.Component**, pero no usa un estado interno. Finalmente, un componente con estado es un componente de clase que mantiene su propio estado interno. Es posible que vea los componentes con estado referidos simplemente como componentes o componentes React.

Un patr√≥n com√∫n es tratar de minimizar la falta de estado y crear componentes funcionales sin estado siempre que sea posible. Esto ayuda a incluir la administraci√≥n de su estado en un √°rea espec√≠fica de su aplicaci√≥n. A su vez, esto mejora el desarrollo y el mantenimiento de su aplicaci√≥n al hacer que sea m√°s f√°cil seguir c√≥mo los cambios de estado afectan su comportamiento.

### React: Crear un Stateful Component

los componentes anteriores Aceptan **props** como entrada y devuelven la misma vista cada vez que se pasan los mismos **props**. Puede que se pregunte qu√© es el estado, Antes de eso, aqu√≠ hay una revisi√≥n de la terminolog√≠a de los componentes. Un componente funcional sin estado es cualquier funci√≥n que usted escribe que acepta **props** y devuelve **JSX**.

Un componente sin estado, por otro lado, es una clase que extiende ```React.Component```, Finalmente, un componente con estado es un componente de clase que mantiene su propio estado interno. Es posible que vea los componentes con estado referidos simplemente como componentes o componentes React. Un patr√≥n com√∫n es tratar de minimizar la falta de estado y crear componentes funcionales sin estado siempre que sea posible. Esto ayuda a incluir la administraci√≥n de su estado en un √°rea espec√≠fica de su aplicaci√≥n. A su vez, esto mejora el desarrollo y el mantenimiento de su aplicaci√≥n al hacer que sea m√°s f√°cil seguir c√≥mo los cambios de estado afectan su comportamiento.

```javascript

class SportSite extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <Athlete/>
      </div>
    );
  }
};


const Athlete = (props) => {
   return (
     <div>
       <p>{props.nombre}</p>
     </div>
   );
};

Athlete.propTypes = {
  nombre: PropTypes.string.isRequired
};

Athlete.defaultProps = {
  nombre: 'Usain Bolt'
};
```

##  ‚ô†Ô∏è Renderizar un Estado en la  Interfaz de usuario

Hay otra forma de acceder al estado en un componente. En el m√©todo ```render()```, antes de la declaraci√≥n de retorno, puede escribir JavaScript directamente. Por ejemplo, podr√≠a declarar funciones, acceder a datos de estado o **props**, realizar c√°lculos en estos datos, etc. Luego, puede asignar cualquier dato a las variables, a las que tiene acceso en la declaraci√≥n de retorno.

```javascript

class MiComponente extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      nombre: 'Guia rapida Reactjs'
    }
  }
  render() {

    const nombre = this.state.nombre;

    return (
      <div>

        <h1>{nombre}</h1>

      </div>
    );
  }
};

```

## ‚ô†Ô∏è crear un this.setState

  Hay una manera de cambiar el estado del componente. React proporciona un m√©todo para actualizar el estado del componente llamado ```setState```. Llama al m√©todo ```setState``` dentro de su clase de componente de esta forma: ```this.setState()```, pasando un objeto con pares clave-valor. Las claves son las propiedades de su estado y los valores son los datos de estado actualizados. Por ejemplo, si estuvi√©ramos almacenando un nombre de usuario en estado y quisi√©ramos actualizarlo, se ver√≠a as√≠:

```javacript
this.setState({
  usuario: 'Linux Torvalds'
});
```

## ‚ô†Ô∏è De Bind 'this' a Class Method

Adem√°s de establecer y actualizar el estado, tambi√©n puede definir m√©todos para su clase de componente. Normalmente, un m√©todo de clase necesita usar esta palabra clave ```this ``` para poder acceder a las propiedades de la clase (como el estado y los props) dentro del alcance del m√©todo. Hay algunas maneras de permitir que sus m√©todos de clase accedan a esto.


Una forma com√∫n es vincular expl√≠citamente esto en el constructor para que se convierta en un enlace a los m√©todos de clase cuando se inicializa el componente. Puede que hayas notado que el √∫ltimo desaf√≠o us√≥ ```this.handleClick = this.handleClick.bind (this)``` para su m√©todo ```handleClick``` en el constructor. Luego, cuando llama a una funci√≥n como ```this.setState()``` dentro de su m√©todo de clase ```this```, esto se refiere a la clase y no quedar√° un ```undefined```


## ‚ô†Ô∏è Usar State to Toggle en un Elemento


MyComponent tiene una propiedad de visibilidad que se inicializa en falso. El m√©todo de renderizaci√≥n devuelve una vista si el valor de visibilidad es verdadero, y una vista diferente si es falso.

Actualmente, no hay forma de actualizar la propiedad de visibilidad en el estado del componente. El valor debe alternar entre verdadero y falso. Hay un controlador de clic en el bot√≥n que activa un m√©todo de clase llamado toggleVisibility (). Defina este m√©todo para que el estado de visibilidad cambie al valor opuesto cuando se llama al m√©todo. Si la visibilidad es falsa, el m√©todo lo establece en verdadero y viceversa.

Finalmente, haga clic en el bot√≥n para ver la representaci√≥n condicional del componente en funci√≥n de su estado.

```javascript

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      visibility: false
    };
    this.toggleVisibility = this.toggleVisibility.bind(this);
   }
  toggleVisibility() {
    this.setState({
      visibility: !this.state.visibility
    });
  }
  render() {
    if (this.state.visibility) {
      return (
        <div>
          <button onClick = {this.toggleVisibility}>Presioname!</button>
          <h1>Ahora puedes verme</h1>
        </div>
      );
    } else {
      return (
        <div>
          <button onClick = {this.toggleVisibility}>Presioname</button>
        </div>
      );
    }
  }
};
```

## ‚ô†Ô∏è Crear un INPUT

Los elementos de control de formulario para la entrada de texto, como input y textarea, mantienen su propio estado en el DOM seg√∫n el tipo de usuario. Con React, puede mover este estado mutable al estado de un componente React. La entrada del usuario se convierte en parte del estado de la aplicaci√≥n, por lo que React controla el valor de ese campo de entrada. Normalmente, si tiene componentes React con campos de entrada en los que el usuario puede escribir, ser√° un formulario de entrada controlado.

```javascript

class ControlledInput extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: ''
    };
    this.handleChange = this.handleChange.bind(this);
  }
  handleChange(event) {
    this.setState({
      input: event.target.value
    });
  }
  render() {
    return (
      <div>
        <input
          value={this.state.input}
          onChange={this.handleChange} />
        <h4> Messsage Input:</h4>

        <p>{this.state.input}</p>
      </div>
    );
  }
};

```

## ‚ô†Ô∏è Crear un Form

El componente MyForm se configura con un formulario vac√≠o con un controlador de env√≠o. Se llamar√° al controlador de env√≠o cuando se env√≠e el formulario.

a√±adi un bot√≥n que env√≠a el formulario. Puede ver que tiene el tipo de conjunto para enviar que indica que es el bot√≥n que controla el formulario. Agregue el elemento de entrada en el formulario y establezca su valor y los atributos ```onChange()```


```javascript

class MyForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      input: '',
      Enviar: ''
    };
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  handleChange(event) {
    this.setState({
      input: event.target.value
    });
  }
  handleSubmit(event) {
    event.preventDefault()
    this.setState({
      Enviar: this.state.input
    });
  }
  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <input
            value={this.state.input}
            onChange={this.handleChange} />
          <button type='Enviar'>Enviado!</button>
        </form>
        <h1>{this.state.Enviar}</h1>
      </div>
    );
  }
};

```




## ‚ô†Ô∏è Pass State como Props a Child Components


Por ejemplo, tal vez tenga un componente de la aplicaci√≥n que presente una barra de navegaci√≥n, entre otros componentes. En su aplicaci√≥n, tiene un estado que contiene mucha informaci√≥n de usuario, pero la barra de navegaci√≥n solo necesita acceso al nombre de usuario del usuario para poder mostrarla. Pasas esa pieza de estado al componente Navbar como prop.


``` javascript

class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: 'guideReact'
    }
  }
  render() {
    return (
       <div>
         <Navbar name={this.state.name}/>
       </div>
    );
  }
};
class Navbar extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
    <div>
      <h1>Hello, my name is: {this.props.name}</h1>
    </div>
    );
  }
};



```

##  ‚ô†Ô∏è Pass un Callback como Props

Puede pasar el estado como props a componentes secundarios, pero no est√° limitado a pasar datos. Tambi√©n puede pasar funciones de controlador o cualquier m√©todo que est√© definido en un componente React a un componente secundario. As√≠ es como permite que los componentes secundarios interact√∫en con sus componentes principales. Le pasas m√©todos a un ```child``` como un apoyo regular. Se le asigna un nombre y usted tiene acceso a ese nombre de m√©todo en ```this.props``` en el componente secundario.


El componente MyApp es el principal que procesar√° los componentes secundarios GetInput y RenderInput. Agregue el componente GetInput al m√©todo de procesamiento en MyApp, luego p√°sele una entrada llamada prop asignada a inputValue del estado de MyApp. Tambi√©n cree un prop llamado handleChange y p√°sele el manejador de entrada handleChange.

A continuaci√≥n, agregue RenderInput al m√©todo de procesamiento en MyApp, luego cree un prop llamado input y pase el inputValue del estado. Una vez que haya terminado, podr√° escribir el campo de entrada en el componente GetInput, que luego invoca el m√©todo del controlador en su elemento principal a trav√©s de prop. Esto actualiza la entrada en el estado del padre, que se pasa como apoyo a ambos hijos. Observe c√≥mo los datos fluyen entre los componentes y c√≥mo la √∫nica fuente de verdad sigue siendo el estado del componente principal. Es cierto que este ejemplo es un poco artificial, pero deber√≠a servir para ilustrar c√≥mo los datos y las devoluciones de llamada se pueden pasar entre los componentes de React.



```javascript
class MyApp extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      inputValue: ''
    }
  this.handleChange = this.handleChange.bind(this);
  }
  handleChange(event) {
    this.setState({
      inputValue: event.target.value
    });
  }
  render() {
    return (
       <div>
         <GetInput
           input={this.state.inputValue}
           handleChange={this.handleChange}/>
         <RenderInput
           input={this.state.inputValue}/>
       </div>
    );
  }
};

class GetInput extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>Get Input:</h3>
        <input
          value={this.props.input}
          onChange={this.props.handleChange}/>
      </div>
    );
  }
};

class RenderInput extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <div>
        <h3>Input Render:</h3>
        <p>{this.props.input}</p>
      </div>
    );
  }
};

```


## ‚ô†Ô∏è Usar el Lifecycle Method componentWillMount

Los componentes de React tienen varios m√©todos especiales que brindan oportunidades para realizar acciones en puntos espec√≠ficos del ciclo de vida de un componente. Estos se denominan m√©todos de ciclo de vida, o ganchos de ciclo de vida, y le permiten capturar componentes en ciertos puntos en el tiempo. Esto puede ser antes de que se procesen, antes de que se actualicen, antes de que reciban accesorios, antes de desmontar, y as√≠ sucesivamente. Aqu√≠ hay una lista de algunos de los principales m√©todos de ciclo de vida:

* componentWillMount()

* componentDidMount()

* componentWillReceiveProps()

* shouldComponentUpdate()

* componentWillUpdate()

* componentDidUpdate()

* componentWillUnmount()

```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
  }
  componentWillMount() {

    console.log('Component is mounting...');

  }
  render() {
    return <div />
  }
};

```

## ‚ô†Ô∏è Metodo componentDidMount

la mayor√≠a de los desarrolladores web, en alg√∫n momento, necesitan llamar a un punto final de API para recuperar datos. Si est√° trabajando con React, es importante saber d√≥nde realizar esta acci√≥n.

La mejor pr√°ctica con React es colocar llamadas API o cualquier llamada a su servidor en el m√©todo de ciclo de vida ```componentDidMount()```. Este m√©todo se llama despu√©s de que un componente se monta en el DOM. Cualquier llamada a ``setState()``` aqu√≠ activar√° una nueva representaci√≥n de su componente. Cuando llama a una ```API``` con este m√©todo y establece su estado con los datos que la ```API``` devuelve, se activar√° autom√°ticamente una actualizaci√≥n una vez que reciba los datos.

```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      activeUsers: null
    };
  }
  componentDidMount() {
    setTimeout( () => {
      this.setState({
        activeUsers: 1273
      });
    }, 2500);
  }
  render() {
    return (
      <div>
        <h1>Active Users: {this.state.activeUsers}</h1>
      </div>
    );
  }
};

```

## ‚ô†Ô∏è Add Event Listeners


El m√©todo ```componentDidMount()``` tambi√©n es el mejor lugar para adjuntar cualquier detector de eventos que necesite agregar para una funcionalidad espec√≠fica. React proporciona un sistema de eventos sint√©ticos que envuelve el sistema de eventos nativo presente en los navegadores. Esto significa que el sistema de eventos sint√©ticos se comporta exactamente igual sin importar el navegador del usuario, incluso si los eventos nativos pueden comportarse de manera diferente entre diferentes navegadores.

Ya ha estado utilizando algunos de estos controladores de synthetic event, como ```onClick()```. El sistema de synthetic event de React es excelente para la mayor√≠a de las interacciones que administrar√° en los elementos DOM. Sin embargo, si desea adjuntar un controlador de eventos al documento o los objetos de la ventana, debe hacerlo directamente.

```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: ''
    };
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleEnter = this.handleEnter.bind(this);  }
  componentDidMount() {

    document.addEventListener('keydown', this.handleKeyPress);

  }
  componentWillUnmount() {

    document.removeEventListener('keydown', this.handleKeyPress);

  }
  handleEnter() {
    this.setState({
      message: this.state.message + 'You pressed the enter key! '
    });
  }
  handleKeyPress(event) {
    if (event.keyCode === 13) {
      this.handleEnter();
    }
  }
  render() {
    return (
      <div>
        <h1>{this.state.message}</h1>
      </div>
    );
  }
};
```

## ‚ô†Ô∏è Administrar Updates con Lifecycle Methods

Otro m√©todo de ciclo de vida es **componentWillReceiveProps()**, que se llama cuando un componente recibe nuevos props. Este m√©todo recibe las nuevas propuestas como un argumento, que generalmente se escribe como **nextProps**. Puede usar este argumento y comparar con **this.props** y realizar acciones antes de que se actualice el componente. Por ejemplo, puede llamar a **setState()** localmente antes de que se procese la actualizaci√≥n.

Otro m√©todo es **componentDidUpdate()**, y se llama inmediatamente despu√©s de que un componente se vuelve a procesar. Tenga en cuenta que la representaci√≥n y el montaje se consideran cosas diferentes en el ciclo de vida del componente. Cuando se carga una p√°gina por primera vez, todos los componentes se montan y aqu√≠ es donde se llaman los m√©todos, por ejemplo, **componentWillMount()** y **componentDidMount()**. Despu√©s de esto, a medida que cambia el estado, los componentes se vuelven a representar.

```javascript

class Dialog extends React.Component {
  constructor(props) {
    super(props);
  }
  componentWillUpdate() {
    console.log('Componente actualizado..');
  }

  componentWillReceiveProps(nextProps) {
    console.log(this.props, nextProps);
  }
  componentDidUpdate() {
    console.log('Componente renderizado');
  }

  render() {
    return <h1>{this.props.message}</h1>
  }
};

class Controller extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: 'Primer mensaje'
    };
 this.changeMessage = this.changeMessage.bind(this);
  }
  changeMessage() {
    this.setState({
      message: 'Segundo Mensaje'
    });
  }
  render() {
    return (
      <div>
        <button onClick={this.changeMessage}>Actulizar</button>
        <Dialog message={this.state.message}/>
      </div>
    );
  }
};

```



## ‚ô†Ô∏è Optimizar Re-Renders con shouldComponentUpdate

Hasta ahora, si alg√∫n componente recibe un nuevo estado o nuevos props, se vuelve a representar a s√≠ mismo ya todos sus childs. Esto suele estar bien. Pero React proporciona un m√©todo de ciclo de vida al que puede llamar cuando los componentes secundarios reciben un nuevo estado o props, y declaran espec√≠ficamente si los componentes deber√≠an actualizarse o no. El m√©todo es **shouldComponentUpdate()**, y toma **nextProps** y **nextState** como par√°metros. Este m√©todo es una forma √∫til de optimizar el rendimiento. Por ejemplo, el comportamiento predeterminado es que su componente se vuelve a procesar cuando recibe nuevos accesorios, incluso si los accesorios no han cambiado. Puedes usar **shouldComponentUpdate()** para evitar esto al comparar los props. El m√©todo debe devolver un valor booleano que indique a React si actualizar o no el componente. Puede comparar los props actuales (this.props) con los props siguientes (nextProps) para determinar si necesita actualizar o no, y devolver verdadero o falso en consecuencia.

```javascript

class OnlyEvens extends React.Component {
  constructor(props) {
    super(props);
  }
  shouldComponentUpdate(nextProps, nextState) {
    console.log('Deberia actualizar?');

    return nextProps.value % 2 === 0;

  }
  componentWillReceiveProps(nextProps) {
    console.log('recibiendo nuevas Props...');
  }
  componentDidUpdate() {
    console.log('componente Re-renderizado.');
  }
  render() {
    return <h1>{this.props.value}</h1>
  }
};

class Controller extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 0
    };
  this.addValue = this.addValue.bind(this);
  }
  addValue() {
    this.setState({
      value: this.state.value + 1
    });
  }
  render() {
    return (
      <div>
        <button onClick={this.addValue}>a√±adir</button>
        <OnlyEvens value={this.state.value}/>
      </div>
    );
  }
};

```

## ‚ô†Ô∏è Concepto Inline Styles


Hay otros conceptos complejos que agregan capacidades poderosas a su c√≥digo React. Pero puede que se est√© preguntando sobre el problema m√°s simple de c√≥mo dise√±ar los elementos JSX que crea en React. Probablemente sepa que no ser√° exactamente lo mismo que trabajar con HTML debido a la forma en que aplica las clases a los elementos JSX.

Si importa estilos de una hoja de estilo, no es muy diferente en absoluto. Aplicas una clase a tu elemento JSX usando el atributo className y aplicas estilos a la clase en tu hoja de estilo. Otra opci√≥n es aplicar estilos en l√≠nea, que son muy comunes en el desarrollo de ReactJS.

Usted aplica estilos en l√≠nea a elementos JSX similares a c√≥mo lo hace en HTML, pero con algunas diferencias JSX. Aqu√≠ hay un ejemplo de un estilo en l√≠nea en HTML:

```html

<div style="color": "red","font-size": "20px">red redow </div>

```

Los elementos JSX usan el atributo de estilo, pero debido a la forma en que JSX se transpila, no puede establecer el valor en una cadena. En su lugar, lo establece igual a un objeto de JavaScript. Aqu√≠ hay un ejemplo:

```javascript

<div style={{"color:":"red", "fontSize": "20px"}}>red redow </div>
```

```javascript

Class Colorful extends React.Component {
  render() {
    return (
      <div style={{"color":"red","fontSize":"72px"}}>Big Red</div>
    );
  }
};
```

## ‚ô†Ô∏è JavaScript Avanzado con React Render Method

Otra forma en que puede utilizar el c√≥digo JavaScript en sus componentes React. Tambi√©n puede escribir JavaScript directamente en sus m√©todos de procesamiento, antes de la declaraci√≥n de retorno, sin insertarlo dentro de llaves. Esto se debe a que a√∫n no est√° dentro del c√≥digo JSX. Cuando desee utilizar una variable m√°s adelante en el c√≥digo JSX dentro de la declaraci√≥n de retorno, coloque el nombre de la variable entre llaves.

```javascript

const inputStyle = {
  width: 400,
  margin: 4
}

class Oraculo extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      userInput: '',
      randomIndex: ''
    }
    this.ask = this.ask.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }
  ask() {
    if (this.state.userInput) {
      this.setState({
        randomIndex: Math.floor(Math.random() * 20),
        userInput: ''
      });
    }
  }
  handleChange(event) {
    this.setState({
      userInput: event.target.value
    });
  }
  render() {
    const possibleAnswers = [
      "Adivina mi nombre" ,"manuel""Intentalo de nuevo","jorge","Intentalo de nuevo","Jordan"
		,"Intentalo de nuevo"
    ];
    const answer = possibleAnswers[this.state.randomIndex];
    return (
      <div>
        <input
          type="text"
          value={this.state.userInput}
          onChange={this.handleChange}
          style={inputStyle} /><br />
        <button onClick={this.ask}>Pregunta al Oraculo</button><br />
        <h3>respuesta:</h3>
        <p>
          {answer}
        </p>
      </div>
    );
  }
};

```


## ‚ô†Ô∏è Renderizar con  If/Else
Otra aplicaci√≥n del uso de JavaScript para controlar su vista renderizada es vincular los elementos que se representan a una condici√≥n. Cuando la condici√≥n es verdadera, una vista se renderiza. Cuando es falso, es una vista diferente. Puede hacer esto con una instrucci√≥n if / else est√°ndar en el m√©todo render () de un componente React.



```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      display: true
    }
 this.toggleDisplay = this.toggleDisplay.bind(this);
 }
  toggleDisplay() {
    this.setState({
      display: !this.state.display
    });
  }
  render() {

    if (this.state.display) {
      return (
         <div>
           <button onClick={this.toggleDisplay}>Toggle Display</button>
           <h1>Displayed!</h1>
         </div>
      );
    } else {
      return (
        <div>
           <button onClick={this.toggleDisplay}>Toggle Display</button>
         </div>
      );
    }
  }
};
```


## ‚ô†Ô∏è Renderizar Conditionally desde Props
 Configurar un componente secundario para tomar decisiones de representaci√≥n.

```javascript

 class Resultados extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    return (
      <h1>
      {
        this.props.fiftyFifty ?
        'Ganaste!' :
        'Perdiste!'
      }
      </h1>
    )
  };
};

class GameOfTruenos extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 1
    }
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState({
      counter: this.state.counter + 1
    });
  }
  render() {
    const expression = Math.random() >= .5;
    return (
      <div>
        <button onClick={this.handleClick}>intentalo de nuevo</button>
        <Resultados fiftyFifty={expression} />
        <p>{'Turn: ' + this.state.counter}</p>
      </div>
    );
  }
};

```

## ‚ô†Ô∏è Usar Array.map()  Dinamicamente renderizando elementos

La representaci√≥n condicional es √∫til, pero es posible que necesite que sus componentes representen un n√∫mero desconocido de elementos. A menudo, en programaci√≥n reactiva, un programador no tiene forma de saber cu√°l es el estado de una aplicaci√≥n hasta el tiempo de ejecuci√≥n, ya que mucho depende de la interacci√≥n de un usuario con ese programa. Los programadores deben escribir su c√≥digo para manejar correctamente ese estado desconocido antes de tiempo. Usar ```Array.map()``` en React ilustra este concepto.

Por ejemplo, creas una aplicaci√≥n simple de "Lista de tareas pendientes". Como programador, no tiene forma de saber cu√°ntos elementos puede tener un usuario en su lista. Debe configurar su componente para que muestre din√°micamente el n√∫mero correcto de elementos de la lista mucho antes de que alguien que usa el programa decida que hoy es el d√≠a de la lavander√≠a.


```javascript

const textAreaStyles = {
  width: 400,
  margin: 6
};

class MiListaDeHacer extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      toDoList: [],
      userInput: ''
    }
    this.handleSubmit = this.handleSubmit.bind(this);
    this.handleChange = this.handleChange.bind(this);
  }
  handleSubmit() {
    const itemsArray = this.state.userInput.split(',');
    this.setState({
      toDoList: itemsArray
    });
  }
  handleChange(e) {
    this.setState({
      userInput: e.target.value
    });
  }
  render() {
    const items = this.state.toDoList.map( (item, i) => {
      return <li key={i}>{item}</li>
    });
    return (
      <div>
        <textarea
          onChange={this.handleChange}
          value={this.state.userInput}
          style={textAreaStyles}
          placeholder="Separar elementos con comas" /><br />
        <button onClick={this.handleSubmit}>Crear una lista</button>
        <h1>My "Hacer" Lista:</h1>
        <ul>
          {items}
        </ul>
      </div>
    );
  }
};

```
## ‚ô†Ô∏è Usar un Array.filter() dinamico en una matriz

El m√©todo de matriz de mapa es una herramienta poderosa que usar√° a menudo cuando trabaje con React. Otro m√©todo relacionado con el mapa es el filtro, que filtra el contenido de una matriz en funci√≥n de una condici√≥n y luego devuelve una nueva matriz. Por ejemplo, si tiene una matriz de usuarios que tienen una propiedad en l√≠nea que puede configurarse como verdadera o falsa, puede filtrar solo aquellos usuarios que est√°n en l√≠nea escribiendo:


```javascript
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [
        {
          username: 'andresshare',
          online: true
        },
        {
          username: 'lorena',
          online: false
        },
        {
          username: 'paola',
          online: true
        },
        {
          username: 'Homero',
          online: false
        },
        {
          username: 'lisa',
          online: true
        },
        {
          username: 'Helen',
          online: true
        }
      ]
    }
  }
  render() {
    const usersOnline = this.state.users.filter(user => {
      return user.online;
    });
    const renderOnlineUsers = usersOnline.map(user => {
      return (
        <li key={user.username}>{user.username}</li>
      );
    });
    return (
       <div>
         <h1>Usuarios en linea</h1>
         <ul>
          {renderOnlineUsers}
        </ul>
       </div>
    );
  }
};
```

Espero que les sea de utilidad, por mi parte fue escrito, para mi yo del futuro y tener presente los conceptos, hasta el proximo post!!
