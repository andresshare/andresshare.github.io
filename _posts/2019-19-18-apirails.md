---
layout: post
title:  "API REST con üíé"
date:   2019-09-9 23:07:10 +0530
categories: Ruby RoR
---

![s](https://media.giphy.com/media/3o6fIUMSMkAz1PVxTy/giphy.gif)


En este post creare un **API** simple  en **RoR**

Cambiare de editor. A modo prueba usare **Nvim**

---
Instalacion Debian [nvim]

```
sudo add-apt-repository ppa:neovim-ppa/unstable
sudo apt-get update
sudo apt-get install neovim
```
Permite copiar y pegar en el portapapeles [opcional]
```
sudo apt install xclip
sudo apt install xsel
```


INSTALACION DE PLUGINS

Verificar que exista el archivo `init.vim`
Ruta:  `~/.config/nvim/init.vim`
Sino existe crearlo con los siguientes pasos

```
cd ~/.config/
mkdir nvim
touch nvim/init.vim
```

Configuracion minima `init.vim`. Adaptelo a sus necesidades

```vim
" Directorio de plugins

set title  " Muestra el nombre del archivo en la ventana de la terminal
set number  " Muestra los n√∫meros de las l√≠neas
set mouse=a  " Permite la integraci√≥n del mouse (seleccionar texto, mover el cursor)

set nowrap  " No dividir la l√≠nea si es muy larga

set cursorline  " Resalta la l√≠nea actual
set colorcolumn=120  " Muestra la columna l√≠mite a 120 caracteres

" Indentaci√≥n a 2 espacios
set tabstop=2
set shiftwidth=2
set softtabstop=2
set shiftround
set expandtab  " Insertar espacios en lugar de <Tab>s

set hidden  " Permitir cambiar de buffers sin tener que guardarlos

set ignorecase  " Ignorar may√∫sculas al hacer una b√∫squeda
set smartcase  " No ignorar may√∫sculas si la palabra a buscar contiene may√∫sculas

set spelllang=en,es  " Corregir palabras usando diccionarios en ingl√©s y espa√±ol


let g:mapleader = ' '  " Definir espacio como la tecla l√≠der

nnoremap <leader>s :w<CR>  " Guardar con <l√≠der> + s

nnoremap <leader>e :e $MYVIMRC<CR>  " Abrir el archivo init.vim con <l√≠der> + e

" Usar <l√≠der> + y para copiar al portapapeles
vnoremap <leader>y "+y
nnoremap <leader>y "+y

" Usar <l√≠der> + d para cortar al portapapeles
vnoremap <leader>d "+d
nnoremap <leader>d "+d

" Usar <l√≠der> + p para pegar desde el portapapeles
nnoremap <leader>p "+p
vnoremap <leader>p "+p
nnoremap <leader>P "+P
vnoremap <leader>P "+P

" Moverse al buffer siguiente con <l√≠der> + l
nnoremap <leader>l :bnext<CR>

" Moverse al buffer anterior con <l√≠der> + j
nnoremap <leader>j :bprevious<CR>

" Cerrar el buffer actual con <l√≠der> + q
nnoremap <leader>q :bdelete<CR>

set termguicolors  " Activa true colors en la terminal

" Activar deoplete al iniciar Neovim
let g:deoplete#enable_at_startup = 1

" Cerrar automaticamente la ventana de vista previa (donde se muestra documentaci√≥n, si existe)

" Activar deoplete al iniciar Neovim
let g:deoplete#enable_at_startup = 1

" Cerrar automaticamente la ventana de vista previa (donde se muestra documentaci√≥n, si existe)
" Archivos ignorados
set wildignore+=*/tmp/*,*.so,*.swp,*.zip
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/](\.(git|hg|svn)|node_modules)$',
  \ 'file': '\v\.(exe|so|dll)$',
  \ }

" Ignorar archivos en .gitignore
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']

call plug#begin('~/.local/share/nvim/plugged')

" Aqu√≠ ir√°n los plugins a instalar
Plug 'scrooloose/nerdtree'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'jiangmiao/auto-pairs'
Plug 'joshdick/onedark.vim'
Plug 'shougo/deoplete.nvim'
Plug 'Shougo/neco-syntax'  " Fuente general de auto completado
Plug 'ervandew/supertab'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'  " Temas para airline
Plug 'Yggdroot/indentLine'
Plug 'pangloss/vim-javascript', { 'for': 'javascript' }

call plug#end()

```

- Instalacion de plugin de configuracion

 Pagina Oficial: [vim-plugin](https://github.com/junegunn/vim-plug)

```bash
curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
```
---


Vamos a Prender esto üî•

Crear un **DIR** al projecto,
Ejemplo: **app_rails_api**

Instalar
> gem install ramaze --no-document

Ramaze es un marco web simple y modular

**ramaze.rb**

```ruby
# hello_world/hello_world.rb
require 'ramaze'

class Hello < Ramaze::Controller
  map '/mi_ruta'
  def index
    'Hello!'
  end
end

Ramaze.start
```
Ejecutamos con

> ruby ramaze.rb

Se mostrara en **localhost:7000**

## Sinatra API

Es una alternativa a otros frameworks para aplicaciones web como Ruby on Rails
Instalar

> gem install sinatra ‚Äìno-document

Creamos una carpeta dentro del projecto **api_sinatra**

api.rb

```ruby
require 'sinatra'

get '/' do
  'Sinatra Activado'
end
```
Ejecutamos con

> ruby api.rb

Se activara en 

```
Listening on localhost:4567, CTRL+C to stop
```



**CURL & HTTP**


cURL, que significa URL del cliente y se puede escribir como curl , es una herramienta de l√≠nea de comandos para la transferencia de archivos con una sintaxis de URL. Es compatible con una serie de protocolos que incluyen HTTP, HTTPS, FTP y muchos m√°s. ¬°HTTP / HTTPS lo convierte en un gran candidato para interactuar con las API!


Es importante comprender la diferencia entre URL, URI, IRI y URN antes de continuar. Tim Berners-Lee defini√≥ en RFC 3986 un "Identificador Uniforme de Recursos (URI)" como "una secuencia compacta de caracteres que identifica un recurso abstracto o f√≠sico" y afirm√≥ que un "URI puede clasificarse como un localizador, un nombre o ambos ‚Äù. Tambi√©n afirm√≥ que el t√©rmino‚Äú Localizador uniforme de recursos ‚Äù(URL) se refiere al subconjunto de URI que, adem√°s de identificar un recurso, proporciona un medio para localizar el recurso describiendo su mecanismo de acceso primario (por ejemplo, su red 'ubicaci√≥n').

D√©jeme simplificar esto. Digamos que ud es un recurso:

Las URL son localizadores (de ah√≠ el nombre). Una URL es la direcci√≥n de su casa: Calle Whatever , 105, Medellin.
Las URN son nombres. Para ud, una URN es tu nombre: Andres Bernal.
Los URI pueden ser un localizador (URL), un nombre (URN) o ambos. B√°sicamente, todas las URL son URI, pero no todas las URI son URL.

Lo √∫nico que puede calificar un URI como URL es si este √∫ltimo incluye c√≥mo encontrar el primero. www.google.com/account no es una URL, solo un URI. Sin embargo, http://www.google.com/account es una URL (y sigue siendo un URI) porque incluye el protocolo (http: //) que se puede usar para acceder al recurso (www.google.com/account) .

Los URN son mucho m√°s simples: solo son nombres.

Un ISBN (como 978-0553293357) es un identificador √∫nico para un libro, lo que lo convierte en un URI, y a√∫n m√°s espec√≠ficamente, una URN.

Finalmente, los IRI son una extensi√≥n de los URI destinados a incluir caracteres del Conjunto de caracteres universal (Kanji japon√©s, por ejemplo). De hecho, los URI se limitan a un subconjunto del conjunto de caracteres ASCII.


En el √°mbito de HTTP, los URI son "cadenas simplemente formateadas que identifican, a trav√©s del nombre, la ubicaci√≥n o cualquier otra caracter√≠stica, un recurso".

Un recurso es lo que vive al otro lado de un URI y un URI solo apunta a un recurso. Eso suena bastante abstracto, as√≠ que veamos el siguiente ejemplo.

> https://www.ruby-lang.org/users

Esta URL apunta a un recurso llamado usuarios. Tenga en cuenta que nunca podremos recuperar este recurso; en cambio, solo podemos obtener una representaci√≥n de la misma seg√∫n lo definido por la restricci√≥n de la Interfaz Uniforme. Entonces podemos decir que un recurso nunca cambia, solo sus representaciones lo hacen.

Entonces, ¬øc√≥mo nombramos los recursos? Despu√©s de todo, los recursos son solo conceptos abstractos se√±alados por los URI. En teor√≠a, puede ser cualquier cosa, ya que los nombres no son importantes para la m√°quina que ser√° el cliente final de su API web. 

![](https://media.giphy.com/media/EhzWrhGlYuvug/giphy.gif)

Pero tambi√©n debemos considerar que estamos construyendo para los seres humanos y todav√≠a estamos lejos de eliminar a los desarrolladores de la ecuaci√≥n. Dado que estamos creando API web para humanos, que los usar√°n para implementar su c√≥digo de cliente, debemos usar conceptos y sem√°nticas que puedan entender. Esto sigue el mismo principio que se usa para nombrar recursos para sitios web.

Lo siguiente se basa en las mejores pr√°cticas para construir una API f√°cil de usar, y no realmente en los est√°ndares web.

Si quiero representar el concepto de una lista de usuarios, simplemente usar√≠a la palabra pluralizada 'users', que es solo un sustantivo. Hacer una solicitud a esta URL devolver√≠a una representaci√≥n que enumera un grupo de 'users'. Cualquiera podr√≠a entender esto, y ver la representaci√≥n solo confirmar√° su idea sobre este recurso.

Con la URL a continuaci√≥n, obtenemos una lista de usuarios.

> https://www.ruby-lang.org/users

Pero, ¬øno deber√≠amos llamarlo https://www.ruby-lang.org/get_users, para que la gente lo entienda m√°s f√°cilmente?

La respuesta es no, pero la pregunta en s√≠ no es est√∫pida. Simplemente no tenemos que incluir este get en la URL porque HTTP ya nos tiene cubiertos. Gracias a los m√©todos HTTP, podemos extraer la mayor cantidad posible del URI que apunta a un recurso. La mejor pr√°ctica aqu√≠ es usar solo nombres para los recursos, y no incluir verbos o palabras sin sentido.

![](https://media.giphy.com/media/X7s4uckfyihGJDrSpo/giphy.gif)

Algunas personas prefieren usar nombres singulares para sus recursos, como usuario. Esta elecci√≥n depende de usted, pero recomiendo simplemente usar la versi√≥n plural. Decida lo que decida, mantengase firme. No use /users y / user /: id en la misma API, es confuso para los desarrolladores. No olvide su objetivo es construir algo f√°cil de usar. no es para ud el codigo. usar√© el plural para los nombres de los recursos, ya que es el m√°s utilizado en la comunidad Ruby.


Ahora que tenemos una API funcional minimalista, es hora de comenzar a usarla. Para hacerlo, utilizaremos curl con el que los datos se pueden transferir a trav√©s de varios protocolos que incluyen, entre otros, HTTP.

Es genial tener esta herramienta en su caja de herramientas como Sofware Developer, especialmente para las API web de un edificio. Se puede usar un navegador web para probar algunas partes de una API web, pero es demasiado limitado para ser realmente √∫til. De hecho, solo podemos ejecutar solicitudes GET usando un navegador, y solo si no hay un Encabezado HTTP para cambiar.

curl nos permite definir las solicitudes de la forma en que las queremos y, por lo tanto, es una gran herramienta para incluir en la documentaci√≥n de API web. Dado que las solicitudes curl se pueden generar y copiar f√°cilmente, son una excelente manera de permitir a los desarrolladores probar su API y ver si todo funciona antes de comenzar a hacer algo.

Google Chrome viene con una funci√≥n de "copiar como curl" integrada en las herramientas del desarrollador.


![](https://media.giphy.com/media/qXJelahXxRLFe/giphy.gif)

## Como funciona CURL

Una solicitud curl se compone de la palabra **curl**, la URL que desea golpear y un conjunto de opciones que le permiten modificar cualquier cosa que desee en la solicitud que se enviar√°.

Aqu√≠ hay algunas opciones que necesitamos saber para escribir nuestras primeras solicitudes:

-H: **Abreviatura de encabezado**, esta opci√≥n nos permite agregar o reemplazar campos de encabezado HTTP. Ejemplo: 
```Content-Type: application/json```

-H "Tipo de contenido: aplicaci√≥n / json"
-d: **Abreviatura de datos**, esta es la opci√≥n que usaremos cuando necesitemos enviar datos al servidor. Ejemplo con una carga JSON: ```-d '{"name": "Andres Bernal"} ```

-i, ‚Äì**include**: Al usar esta opci√≥n, curl no solo mostrar√° el cuerpo de la respuesta enviada, sino tambi√©n los encabezados.

-I, ‚Äì**head**: Esta opci√≥n le dice a curl que haga una solicitud HEAD que solo obtendr√° el encabezado de un documento y no su cuerpo.

-X, ‚Äì**request**: esta opci√≥n especifica qu√© tipo de m√©todo HTTP queremos usar en nuestra solicitud. El valor predeterminado es GET, pero podemos usar esta opci√≥n para enviar solicitudes POST, PUT, PATCH o DELETE, por ejemplo.

Necesitamos una biblioteca para serializar la lista de usuarios a XML, y vamos a usar gyoku para ese prop√≥sito.

Ejecute el siguiente comando en su terminal para instalar la √∫ltima versi√≥n de gyoku.


> gem install gyoku  --no-document


```ruby

require 'sinatra'
require 'json'
require 'gyoku'

users ={
  'Lorena':{first_name:'lorena',last_name:'Solarte',age: 30},
  'Andres':{first_name:'Andres',last_name:'Share',age:45},
  'Karen':{first_name:'Karen',last_name:'Valdez',age:20}
}

helpers do

  def json_or_default?(type)
    ['application/json', 'application/*', '*/*'].include?(type.to_s)
  end

  def xml?(type)
    type.to_s == 'application/xml'
  end

  def accepted_media_type
    return 'json' unless request.accept.any?

    request.accept.each do |mt|
      return 'json' if json_or_default?(mt)
      return 'xml' if xml?(mt)
    end

    halt 406, 'Not Acceptable'
  end

end

get '/' do
  'Sinatra Activado'
end

get '/users' do
  type = accepted_media_type

  if type == 'json'
    content_type 'application/json'
    users.map { |name, data| data.merge(id: name) }.to_json
  elsif type == 'xml'
    content_type 'application/xml'
    Gyoku.xml(users: users)
  end
end

```

> curl -i http://localhost:4567/users \ -H "Accept: application/xml;q=0.5, application/json"

![uri](https://media.giphy.com/media/J6JgONWEh7PjXbd78k/giphy.gif)


Como usar los verbos HTTP
Una de las caracter√≠sticas m√°s subestimadas de HTTP son sus m√©todos. ¬øPor qu√© subestimado? Debido a que los navegadores, los clientes de API web m√°s utilizados en el mundo, y el formato HTML, el formato web m√°s utilizado en el mundo, no los utilizan por completo.

Hemos visto antes que los sitios web son solo API web con un navegador web como cliente, que generan HTML en lugar de JSON o XML. A√∫n as√≠, tenemos dos programas inform√°ticos que se comunican entre s√≠, un navegador web y un servidor web. Lamentablemente, HTML solo admite dos m√©todos HTTP: GET y POST. Ya sabe GET, ya que lo he usado varias veces. ¬øPero realmente sabe qu√© son los m√©todos HTTP? ¬øSabes qu√© significa idempotente? o ¬øPor qu√© algunos m√©todos se clasifican como "seguros"? 

¬øQue es un metodo seguro?

Cuando trabajas con una API web, a veces necesitas crear o destruir algunos datos. Otras veces, solo necesita recuperar algunos datos sin ser destructivo.

Eso es exactamente por qu√© algunos m√©todos se consideran "seguros"; no deber√≠an tener ning√∫n efecto secundario y solo deber√≠an recuperar datos. Por supuesto, puede implementar algo en su API web cuando se llama a un m√©todo seguro, como actualizar la cuota de ese usuario, por ejemplo. Sin embargo, el cliente no se hace responsable de esas modificaciones, ya que no las solicit√≥ y consider√≥ que el m√©todo es seguro de usar.

Los √∫nicos m√©todos seguros son GET y HEAD.

 Si ejecuto la solicitud GET / users en nuestra API de Sinatra, no hay efectos secundarios. Seguir√© obteniendo una lista de usuarios y puedo ejecutarla tantas veces como quiera. Esto me lleva a la **idempotencia**.

 ![](https://media.giphy.com/media/zBdfuQVMClAis/giphy.gif)
 
 Que es le Metodo de  **idempotencia** ?

  La idempotencia es propiedad de algunas operaciones en matem√°ticas e inform√°tica, donde ejecutar la misma operaci√≥n varias veces no cambiar√° el resultado despu√©s de la ejecuci√≥n inicial. Tiene el mismo significado en el contexto HTTP.

El impacto de enviar 10 solicitudes HTTP con un m√©todo idempotente es el mismo que enviar una sola solicitud.

Los m√©todos idempotentes son GET, HEAD, PUT, DELETE, OPTIONS y TRACE.

Si env√≠o la misma solicitud GET varias veces, deber√≠a obtener la misma representaci√≥n, una y otra vez. Hay algunas situaciones que pueden eliminar la propiedad de idempotencia de un m√©todo, como cuando surge un error o la cuota del usuario est√° llena. Necesitamos mantener una mentalidad pragm√°tica hacia la idempotencia al construir API web.

Es lo mismo con DELETE, que no deber√≠a generar un error cuando un cliente intenta eliminar un recurso que ya se ha eliminado. Sin embargo, no estoy seguro de que sea lo mejor que pueda hacer, ya que, desde un punto de vista pragm√°tico, le gustar√≠a informar al cliente que ya se elimin√≥ y que puede dejar de enviar la misma solicitud.

Ya usamos GET en la peque√±a API. Ahora que hay m√°s m√©todos, ¬°es hora de implementarlos!

## Todos lo metodos en el API

GET es seguro e idempotente. Este m√©todo est√° destinado a recuperar informaci√≥n del recurso especificado en forma de una representaci√≥n.

El m√©todo GET tambi√©n se puede usar como "GET condicional" cuando se usan campos de encabezado condicional y como "GET parcial" cuando se usa el campo de encabezado Range.

Como recordatorio, aqu√≠ est√° nuestro punto final GET para el recurso de los usuarios.


``` ruby
get '/users' do
  type = accepted_media_type

  if type == 'json'
    content_type 'application/json'
    users.map { |name, data| data.merge(id: name) }.to_json
  elsif type == 'xml'
    content_type 'application/xml'
    Gyoku.xml(users: users)
  end
end
```

Tambi√©n vamos a necesitar una forma de recuperar usuarios espec√≠ficos; Para hacer esto, necesitamos tener un URI disponible para cada usuario. Cada usuario ser√° un recurso y obtendremos representaciones para ese usuario espec√≠ficamente. Afortunadamente, no tenemos que codificar cada URI como / users / thibault, / users / john y as√≠ sucesivamente, ¬°eso ser√≠a dif√≠cil de hacer! Podemos usar un URI de coincidencia como / users /: first_name.

```ruby

 webapi.rb
# ...
# get '/users'

get '/users/:first_name' do |first_name|
  type = accepted_media_type

  if type == 'json'
    content_type 'application/json'
    users[first_name.to_sym].merge(id: first_name).to_json
  elsif type == 'xml'
    content_type 'application/xml'
    Gyoku.xml(first_name => users[first_name.to_sym])
  end
end
```

Es muy similar a obtener '/ usuarios', la principal diferencia son los datos que enviamos de vuelta al cliente. Aqu√≠ seleccionamos el usuario deseado de nuestro hash de datos y lo enviamos de vuelta al cliente despu√©s de serializarlo. Para JSON, utilizamos los usuarios [first_name] .merge (id: first_name) .to_json y para XML Gyoku.xml (first_name => users [first_name]).

Hagamos una solicitud de curl para cada formato disponible. Primero, detenga su servidor si se est√° ejecutando y rein√≠cielo con ruby ‚Äã‚Äã.rb.

Con JSON, el formato predeterminado:

 Ejecute 
> sinatra_api.rb

curl
> curl http://localhost:4567/users/thibault

* No intente consultar a usuarios que a√∫n no existen; todav√≠a no estamos manejando errores! Habr√° una secci√≥n completa sobre eso en el pr√≥ximo cap√≠tulo.


El m√©todo HEAD funciona casi de la misma manera que el m√©todo GET. La √∫nica diferencia es que el servidor no debe devolver un cuerpo despu√©s de recibir una solicitud HEAD. Los encabezados HTTP recibidos por el cliente deben ser exactamente como los que recibir√≠a de una solicitud GET.

HEAD es seguro e idempotente. Se puede usar para probar un URI antes de enviar una solicitud para recuperar datos.

Agreguemos soporte para este m√©todo en nuestra API web. Primero podemos duplicar la ruta get '/ users'. Solo hay dos cambios que hacer despu√©s de eso. Cambiando a la cabeza y evitando que alguien sea enviado, eliminando:

```ruby
users.map { |name, data| data.merge(id: name) }.to_json
```
y

```ruby
Gyoku.xml(users: users)
```

Terminamos con lo siguiente, que enviar√° los mismos encabezados que una solicitud GET, menos el cuerpo:

```ruby
# sinatra_api.rb
# ...
# get '/users'
# get '/users/:first_name'

head '/users' do
  type = accepted_media_type

  if type == 'json'
    content_type 'application/json'
  elsif type == 'xml'
    content_type 'application/xml'
  end
end

```
Restart your server after adding this route.


Para ejecutar una solicitud HEAD con curl, necesitamos usar la opci√≥n -I. Simplemente usando la opci√≥n -X y configur√°ndolo en HEAD (-X HEAD) enviar√° correctamente una solicitud HEAD, pero luego esperar√° a que se reciban los datos. Tambi√©n usemos la opci√≥n detallada (-v) para ver si la solicitud enviada cumple con nuestras expectativas.

> curl -I -v http://localhost:4567/users


Aqu√≠ est√° la solicitud enviada ...

```
HEAD /users HTTP/1.1
Host: localhost:4567
User-Agent: curl/7.43.0
Accept: */*
```

y la respuesta recibida:

```bash
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 162
X-Content-Type-Options: nosniff
Connection: keep-alive
Server: thin
```


¬°Todo bien! Parece que seguimos correctamente el RFC HTTP para implementar nuestro punto final HEAD. El c√≥digo es una gran duplicaci√≥n del punto final GET; no se preocupe, lo refactorizaremos una vez que tengamos todos nuestros puntos finales. Por ahora, centr√©monos en aprender m√°s sobre los m√©todos restantes.


## POST


POST es tan famoso como GET porque es el √∫nico otro m√©todo HTTP compatible con el formato HTML. La creaci√≥n de aplicaciones web generalmente gira en torno al uso de GET para obtener algunos documentos HTML o POST para publicar alg√∫n tipo de datos que har√°n cualquier cosa, desde crear hasta actualizar o eliminar entidades.

Bueno, desafortunadamente eso realmente no sigue lo que se define en el HTTP RFC. Se supone que POST se usa solo para crear nuevas entidades, ya sea como un nuevo registro de base de datos o como una anotaci√≥n de un recurso existente.

Centr√©monos en el m√©todo POST como un medio para crear un nuevo registro del recurso identificado en la solicitud. No es seguro ni idempotente crear nuevos registros.

El RFC tambi√©n especifica c√≥mo responder al cliente utilizando c√≥digos de estado espec√≠ficos como 200 (OK), 204 (Sin contenido) o 201 (Creado). Los primeros dos c√≥digos solo deben usarse si la entidad creada no puede ser identificada por un URI; 200 cuando la respuesta contiene un cuerpo y 204 cuando no. De lo contrario, 201 deber√≠a devolverse con el encabezado de ubicaci√≥n establecido en el URI de esta nueva entidad.


![](https://media.giphy.com/media/Ar6FcSKA6TnkA/giphy.gif)



> Una pr√°ctica recomendada es devolver la entidad reci√©n creada como el cuerpo de una solicitud POST. Solo debe hacerse si los datos de la entidad que se cre√≥ y los datos que se enviaron con la solicitud son diferentes. Por ejemplo, si se agreg√≥ un nuevo campo como created_at durante la creaci√≥n, entonces devolver la entidad de inmediato tiene sentido y evita que el cliente realice otra llamada con el URI presente en el encabezado de Ubicaci√≥n. En nuestra API de Sinatra, devolveremos 201 sin un cuerpo, pero cuando trabajemos en nuestra pr√≥xima API, comenzaremos a enviar entidades de regreso de inmediato. Tambi√©n puede decidir enviar de vuelta

Agreguemos un punto final POST para crear nuevos usuarios en nuestra API. Como no conservamos nada, solo agregaremos el usuario enviado al hash de los usuarios. No vamos a manejar ning√∫n error por ahora, por lo que si env√≠a algo que no sea un JSON v√°lido, se bloquear√°.

No se preocupe, agregaremos el manejo de errores muy pronto.

Puede encontrar el c√≥digo para este punto final a continuaci√≥n. En el c√≥digo, primero obtenemos la carga √∫til de la solicitud con request.body.read que luego analizamos para obtener un hash Ruby. Luego almacenamos el usuario recibido en el hash de nuestros usuarios usando el nombre de usuario first_name como clave. Finalmente, enviamos 201 al cliente para confirmar la creaci√≥n.


```ruby
# sinatra_api.rb
# ...
# get '/users'
# get '/users/:first_name'
# head '/users'

post '/users' do
  user = JSON.parse(request.body.read)
  users[user['first_name'].downcase.to_sym] = user

  url = "http://localhost:4567/users/#{user['first_name']}"
  response.headers['Location'] = url   

  status 201
end

`Reinicie su servidor despu√©s de agregar esta ruta.


```bash
curl -X POST -v http://localhost:4567/users \
     -H "Content-Type: application/json" \
     -d '{"first_name":"Samuel","last_name":"Da Costa","age":19}'
```

Request Sent:


```ruby

POST /users HTTP/1.1
Host: localhost:4567
User-Agent: curl/7.43.0
Accept: */*
Content-Type: application/json
Content-Length: 55

.. {JSON data} ...
```
Todo parece estar funcionando bien! Podemos volver a verificar obteniendo nuestra lista de usuarios.

> curl http://localhost:4567/users

```json
[
  {"first_name":"Thibault", "last_name":"Denizet", "age":25},
  {"first_name":"Simon", "last_name":"Random", "age":26},
  {"first_name":"John", "last_name":"Smith", "age":28},
  {"first_name":"Samuel", "last_name":"Da Costa", "age":19}
]
```

****PENDIENTE SEGUIR Y MODIFICAR JSon